# -*- coding: utf-8 -*-
"""Girardy_Momplaisir_midterm_P1P2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EDMvuM_c03dmUApeEjkbannSnDLLI7Eo

<h1 style="text-align:center; font-size:24">
BIOCB 4381/6381 Midterm<br>
<br>
Due Tuesday, November 5th, 11:59 PM (via Canvas) <br>
</h1>

<div style="background-color: #fffee8; border-color: #f6f4c7; border-left: 5px solid #f6f4c7; padding: 1.5em; color: #403f30">

#### Please comment your code wherever you feel necessary. You are free to add new cells to solve problems or test your code. Good luck!
                                                                               
<div/>
"""

# Modules that you may need in this problem set
!pip install Bio
import os
import sys
import copy
import traceback

import re

import pandas as pd
import numpy as np

from Bio import SeqIO

"""<h3 style="background-color: #daebff; border-color: #bad5f6; border-left: 5px solid #bad5f6; padding: 1.5em; color: #6f89a9">
Problem 1 Needleman-Wunsch Algorithm
</h3>

### (a) Construct similarity matrix for a pair of sequences
"""

def get_sim_mat(seq1, seq2):
    """
    Construct a similarity matrix for two sequences
    Args:
        seq1 [str]: sequence 1 (vertical)
        seq2 [str]: sequence 2 (horizontal)
    Returns:
        sim_mat [2D-list or 2D-array]: similarity matrix where 1=match, 0=mismatch
    """
    ### YOUR SOLUTION STARTS HERE ###
    sim_mat=np.zeros((len(seq1),len(seq2)))
    for i in range(len(seq1)):
        for j in range(len(seq2)):
            if seq1[i]==seq2[j]:
                sim_mat[i][j]=1
            else:
              sim_mat[i][j]=0
    return sim_mat

    ### YOUR SOLUTION ENDS HERE ###

# Test case
seq1 = "AYCYNRCKCRBP"
seq2 = "ABCNYRQCLCRPM"

sim_mat_test = get_sim_mat(seq1, seq2)
sim_mat_test



"""### (b) Update cell value"""

def update_cell_value(current_matrix, i, j):
    """
    Update cell [i,j] in the matrix
    Args:
        current_matrix [2D-list or 2D-array]: current matrix we have (same type as the output in 1(a))
        i, j [int]: row, column index
    Returns:
        updated value for cell i,j
    """
    ### YOUR SOLUTION STARTS HERE ###
    currentvalue= current_matrix[i,j]
    if i+1 <len(current_matrix) and j+1 <len(current_matrix[0]):
        diagonal=current_matrix[i+1,j+1]
    else:
        diagonal=0
    if i+1 <len(current_matrix) and j+2 < len(current_matrix[0]):
        row_gap=max(current_matrix[i+1,j+2:])
    else:
        row_gap=0
    if i + 2 < len(current_matrix) and j+1 < len(current_matrix[0]):
        col_gap = max(current_matrix[x, j + 1] for x in range(i + 2, len(current_matrix)))
    else:
        col_gap = 0

    return max(diagonal,row_gap,col_gap) + currentvalue



    ### YOUR SOLUTION ENDS HERE ###

# Test case
# You can create your own test cases if you want (e.g. modify i,j)

update_cell_value(sim_mat_test, 9, 10)



"""### (c) Generate whole sum matrix"""

def get_sum_mat(sim_mat):
    """
    Update values for the whole matrix to obtain the final sum matrix
    Args:
        sim_mat [2D-list or 2D-array]: similarity matrix of 1's and 0's (output from 1(a))
    Returns:
        sum_mat [2D-list or 2D-array]: sum matrix
    """
    ### YOUR SOLUTION STARTS HERE ###
    for i in range(len(sim_mat)-1,-1,-1):
        for j in range(len(sim_mat[0])-1,-1,-1):
            sim_mat[i,j]=update_cell_value(sim_mat,i,j)
    return sim_mat
    ###

    ### YOUR SOLUTION ENDS HERE ###

# Test case

sum_mat_test = get_sum_mat(sim_mat_test)
sum_mat_test





"""### (d) Find cell with the maximum value (to start tracing back)"""

def find_max_cell(sum_mat):

    ### YOUR SOLUTION STARTS HERE ###
    max_value=0
    max_cell=(0,0)
    for i in range(len(sum_mat)-1,-1,-1):
                for j in range(len(sum_mat[0])-1,-1,-1):
                      if max_value < sum_mat[i,j]:
                        max_value=sum_mat[i,j]
                        max_cell=(i,j)
    return max_cell

    ### YOUR SOLUTION ENDS HERE ###

# Test case

max_cell = find_max_cell(sum_mat_test)
max_cell





"""### (e) Find next cell with the maixumum value"""

def find_next_maxcell(sum_matrix, i, j):
    """
    Find the next cell with the maximum value in the scanned area
    Args:
        sum_mat [2D-list or 2D-array]: sum matrix (output from 1(c))
        i, j [int]: row, column index of the current cell
    Returns:
        (i, j) [tuple of int]: row, column index of the next cell to trace back with the maximum value in the scanned area
    """
    ### YOUR SOLUTION STARTS HERE ###
    max_value=0
    max_cell=(i,j)
    if i + 1 < len(sum_matrix):
        for y in range(j + 1, len(sum_matrix[0])):
            if sum_matrix[i + 1, y] > max_value:
                max_value = sum_matrix[i + 1, y]
                max_cell = (i + 1, y)
            elif sum_matrix[i + 1, y] == max_value and max_cell == (None, None):
                max_cell = (i + 1, y)

    if j + 1 < len(sum_matrix[0]):
        for x in range(i + 1, len(sum_matrix)):
            if sum_matrix[x, j + 1] > max_value:
                max_value = sum_matrix[x, j + 1]
                max_cell = (x, j + 1)
            elif sum_matrix[x, j + 1] == max_value and max_cell == (None, None):
                max_cell = (x, j + 1)

    if i == len(sum_matrix) - 1 or j == len(sum_matrix[0]) - 1 or max_cell==(i,j):
        return (None, None)

    return max_cell


    ### YOUR SOLUTION ENDS HERE ###

# Test case

next_max_cell = find_next_maxcell(sum_mat_test, 0, 0)
next_max_cell





"""### (f) Find the trace-back path"""

def trace_back(sum_mat):
  """
      Find the trace-back path
      Args:
          sum_mat [2D-list or 2D-array]: sum matrix (output from 1(c))
      Returns:
          [(i_1, j_1), ..., (i_n, j_n)] [list of tuples of int]: a list containing the row, column indices of the cells in the trace-back path (if there are n cells in total in the trace-back path)
  """
    ### YOUR SOLUTION STARTS HERE ###
  max_cell=find_max_cell(sum_mat)
  trace_list=[]
  trace_list.append(max_cell)
  while max_cell[0]!=None and max_cell[1]!=None:
       max_cell=find_next_maxcell(sum_mat,max_cell[0],max_cell[1])
       if max_cell[0]!=None and max_cell[1]!=None:
          trace_list.append(max_cell)

  return trace_list


    ### YOUR SOLUTION ENDS HERE ###

# Test case

trace_list = trace_back(sum_mat_test)
trace_list





"""### (g) Get alignment"""

def get_alignment(seq1, seq2):
  """
    Get the final alignment
	Args:
        seq1 [str]: sequence 1 (vertical)
        seq2 [str]: sequence 2 (horizontal)
    Returns:
        (seq1_aligned, seq2_aligned) [tuple of str]: aligned seq1 and seq2 with matched characters or gaps
  """
      ### YOUR SOLUTION STARTS HERE ###
      # 1. Get similarity matrix using get_sim_mat(seq1, seq2)
  similarity_mat=get_sim_mat(seq1,seq2)

      # 2. Get sum matrix using get_sum_mat(sim_mat)
  sim_sum_mat=get_sum_mat(similarity_mat)

      # 3. Get trace back path using trace_back(sum_mat)
  trace_list_align=trace_back(sim_sum_mat)
  print(trace_list_align)

      # 4. Get the final alignment based on trace-back path
  seq1_aligned = ""
  seq2_aligned = ""
  prev=(0,0)

  for (i, j) in trace_list_align:
        if i == 0 and j == 0:
            seq1_aligned += seq1[i]
            seq2_aligned += seq2[j]
            prev=(i,j)
        elif i > 0 and  j > 0 and seq1[i]==seq2[j]:
          for k in range(prev[0]+1,i):
            seq1_aligned += seq1[k]
            seq2_aligned += "-"
          seq1_aligned += seq1[i]
          seq2_aligned += seq2[j]
          prev=(i,j)

  if prev[0] < len(seq1) - 1:
        for k in range(prev[0] + 1, len(seq1)):
            seq1_aligned += seq1[k]
            seq2_aligned += "-"


  print("Aligned seq1:", seq1_aligned)
  print("Aligned seq2:", seq2_aligned)

      ### YOUR SOLUTION ENDS HERE ###

# Test case
seq1 = "ATTCGA"
seq2 = "ACG"

alignment = get_alignment(seq1, seq2)
alignment

"""<h3 style="background-color: #daebff; border-color: #bad5f6; border-left: 5px solid #bad5f6; padding: 1.5em; color: #6f89a9">
Problem 2 SAM File Parsing
</h3>

### (a) Parse single row from a SAM file
"""

def parse_sam_row(row, headers):
    """
    Parse a single row from alignment section in SAM file to a dictionary
    Args:
        row [str]: a row from the alignment section of a SAM file
        headers [list]: names of 11 mandatory SAM fields
    Returns:
        sam_dict [dict]: maps names of 11 mandatory fields to corresponding values
    """
    ### YOUR SOLUTION STARTS HERE ###
    fields = row.strip().split('\t')
    sam_dict = {}
    for i in range(len(headers)):
        sam_dict[headers[i]] = fields[i]
    return sam_dict

    ### YOUR SOLUTION ENDS HERE ###

# test case
with open('test_sam_row.txt', 'r') as f:
    test_row = f.readlines()

headers = ["QNAME", "FLAG", "RNAME", "POS", "MAPQ", "CIGAR", "RNEXT", "PNEXT", "TLEN", "SEQ", "QUAL"]
parse_sam_row(test_row[0].strip(), headers)



"""### (b) Parse SAM file"""

import pandas as pd

def parse_sam_file(fname, headers, int_cols):
    """
    Parse a SAM file to a dictionary
    Args:
        fname [str]: path of the SAM file
        headers [list]: names of 11 mandatory SAM fields
        int_cols [list]: names of fields that should be treated as integers
    Returns:
        sam_df [pandas.DataFrame]: a data frame of the parsed SAM file, where each column corresponds to a field
    """

    ### YOUR SOLUTION STARTS HERE ###
    with open(fname, 'r') as file:
        lines = file.readlines()

    data = [parse_sam_row(line, headers) for line in lines if not line.startswith('@')]
    sam_df = pd.DataFrame.from_dict(data)
    for col in int_cols:
        sam_df[col] = sam_df[col].astype(int)

    return sam_df

    ### YOUR SOLUTION ENDS HERE ###

# test case

headers = ["QNAME", "FLAG", "RNAME", "POS", "MAPQ", "CIGAR", "RNEXT", "PNEXT", "TLEN", "SEQ", "QUAL"]
int_cols = ["FLAG", "POS", "MAPQ", "TLEN"]
parsed_sam = parse_sam_file("Clone_Seq_Aligned.sam", headers, int_cols)
parsed_sam.head()





"""### (c) Decode FLAG"""

def decode_FLAG(flag):
    """
    Decode a decimal FLAG number into a binary string with 12 characters
    Args:
        flag [int]: a decimal FLAG number
    Returns:
        bin_str [str]: a binary string with 12 characters
    """

    ### YOUR SOLUTION STARTS HERE ###
    bin_str = bin(flag)[2:].zfill(12)
    return bin_str

    ### YOUR SOLUTION ENDS HERE ###

# test case

decode_FLAG(99)



"""- The meaning of FLAG=99 is:

Your answer:000001100011
As the binary string 000001100011, bit 1 is set to 1, indicating that the read is part of a pair, and Bit 2 is also set, showing that the read is mapped in a proper pair, meaning it aligns correctly with its mate according to the sequencing protocol. Bit 3 is not set, which means the read itself is mapped, and Bit 4 is also unset, indicating that the mate is mapped as well. Bit 5 is not set, signifying that the read is on the forward strand, while Bit 6 is set, showing that the mate is on the reverse strand. Lastly, Bit 7 is set, indicating that this read is the first in the pair. The remaining bits are not set.So the read is paired. It is mapped in a proper pair.The mate is on the reverse strand and the read is the first in the pair.

"""